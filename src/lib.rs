mod filter;
use filter::Where;

pub type RawDbOutput = str;

pub trait DbParseable<T> {
    fn db_parse(&self) -> T;
}

impl DbParseable<u32> for RawDbOutput {
    fn db_parse(&self) -> u32 {
        self.parse().expect("Error Parsing string to int")
    }
}

impl DbParseable<String> for RawDbOutput {
    fn db_parse(&self) -> String {
        self.to_string()
    }
}

pub trait DbMemberTrait {
    const SELECT: &'static str;
    const NAME: &'static str;
    fn build_from_query(args: Vec<&RawDbOutput>) -> Self;
    fn query_builder() -> String {
        format!("SELECT {} FROM {}", Self::SELECT, Self::NAME)
    }
}

pub trait DbObject<T: DbMemberTrait> {
    type WhereType;

    fn raw_query(_query: String) -> String {
        return String::from("0,Greg,Presser\n1,First,Last\n2,Second,SLast");
    }

    fn find_many(filter: Vec<Where<Self::WhereType>>) -> Vec<T> {
        let resp = Self::raw_query(T::query_builder());

        return resp
            .split('\n')
            .map(|s| T::build_from_query(s.split(',').collect()))
            .collect();
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use karisma_derive::DBTraits;

    // **This is generated by CLI
    #[derive(DBTraits)]
    #[model(User)]
    struct User {
        pub id: u32,
        pub first_name: String,
        pub last_name: String,
    }

    enum UserTypes {
        Id(u32),
        FirstName(String),
        LastName(String),
    }

    // Generation ended**

    // this is made by User to collect specific data
    #[derive(DBTraits)]
    #[model(User)]
    struct UserData {
        pub id: u32,
        pub first_name: String,
    }

    // Generate this
    // impl DbMemberTrait for UserData {
    //     const SELECT: &'static str = "id,first_name";
    //     const NAME: &'static str = "User";
    //     fn build_from_query(args: Vec<&str>) -> Self {
    //         Self {
    //             id: args[0].db_parse(),
    //             first_name: args[1].db_parse(),
    //         }
    //     }
    // }
    // impl DbObject<UserData> for User {}

    #[test]
    fn test_default() {
        let a: Vec<User> = User::find_many(vec![]);
        assert_eq!(a[0].id, 0);
        assert_eq!(a[0].first_name, "Greg");
        assert_eq!(a[0].last_name, "Presser");
        assert_eq!(a[1].id, 1);
        assert_eq!(a[1].first_name, "First");
        assert_eq!(a[1].last_name, "Last");
        assert_eq!(a[2].id, 2);
        assert_eq!(a[2].first_name, "Second");
        assert_eq!(a[2].last_name, "SLast");
    }

    #[test]
    fn test_select() {
        let a: Vec<UserData> = User::find_many(vec![]);
        assert_eq!(a[0].id, 0);
        assert_eq!(a[0].first_name, "Greg");
        assert_eq!(a[1].id, 1);
        assert_eq!(a[1].first_name, "First");
        assert_eq!(a[2].id, 2);
        assert_eq!(a[2].first_name, "Second");
    }
}
